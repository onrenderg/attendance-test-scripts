<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Face Attendance</title>
    <script>
        // Fetch polyfill for file:// URLs - required for face-api.js model loading in Android WebView
        (function () {
            const originalFetch = window.fetch;
            window.fetch = function (input, init) {
                let url = typeof input === 'string' ? input : (input && input.url ? input.url : null);
                if (!url) return originalFetch.call(window, input, init);

                // Convert relative URLs to file:// URLs
                if (!url.startsWith('http') && !url.startsWith('file://')) {
                    const base = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                    if (url.startsWith('./')) {
                        url = base + url.substring(2);
                    } else if (url.startsWith('/')) {
                        url = 'file://' + url;
                    } else {
                        url = base + url;
                    }
                }

                // Handle file:// URLs with XHR
                if (url.startsWith('file://')) {
                    return new Promise((resolve, reject) => {
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', url, true);
                        xhr.responseType = 'arraybuffer';

                        xhr.onload = function () {
                            if (xhr.status === 0 || xhr.status === 200) {
                                const arrayBuffer = xhr.response;
                                const headers = new Headers();
                                headers.set('content-type', url.endsWith('.json') ? 'application/json' : 'application/octet-stream');

                                resolve({
                                    ok: true,
                                    status: 200,
                                    headers: headers,
                                    url: url,
                                    json: function () {
                                        const text = new TextDecoder().decode(arrayBuffer);
                                        return Promise.resolve(JSON.parse(text));
                                    },
                                    text: function () {
                                        return Promise.resolve(new TextDecoder().decode(arrayBuffer));
                                    },
                                    arrayBuffer: function () {
                                        return Promise.resolve(arrayBuffer);
                                    },
                                    blob: function () {
                                        return Promise.resolve(new Blob([arrayBuffer]));
                                    }
                                });
                            } else {
                                reject(new Error('XHR failed: ' + xhr.status + ' for ' + url));
                            }
                        };
                        xhr.onerror = function () {
                            reject(new Error('XHR error for ' + url));
                        };
                        xhr.send();
                    });
                }
                return originalFetch.call(window, input, init);
            };
        })();
    </script>
    <script src="static/js/face-api.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial;
            text-align: center;
            background: #1a1a2e;
            color: white;
            min-height: 100vh;
            padding: 10px;
        }

        h1 {
            font-size: 18px;
            margin: 10px 0;
        }


        video {
            width: 100%;
            max-width: 420px;
            height: 500px;
            /* Add explicit height */
            object-fit: cover;
            /* Prevent distortion */
            border: 3px solid #00d4ff;
            border-radius: 10px;
        }

        button {
            padding: 12px 20px;
            margin: 8px 5px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            color: white;
            display: none !important;
            /* Hide manual buttons */
        }

        .register {
            background: #4CAF50;
        }

        .clear {
            background: #f44336;
        }

        input {
            padding: 10px;
            font-size: 14px;
            border-radius: 5px;
            border: none;
            margin: 8px;
            width: 60%;
            display: none !important;
            /* Hide manual input */
        }

        #result {
            margin: 10px;
            padding: 15px;
            font-size: 16px;
            border-radius: 10px;
        }

        .success {
            background: #4CAF50;
        }

        .error {
            background: #f44336;
        }

        .info {
            background: #333;
        }

        #status {
            color: #00d4ff;
            margin: 8px;
            font-size: 14px;
        }

        #blinkCount {
            font-size: 22px;
            color: #ff9800;
            margin: 10px;
        }

        #dbCount {
            color: #888;
            font-size: 12px;
            margin: 5px;
        }
    </style>
</head>

<body>

    <div id="status">Loading models...</div>
    <div id="blinkCount">üëÄ Eyes Open</div>
    <video id="video" autoplay playsinline muted></video>
    <br>
    <input type="text" id="name" placeholder="Enter name">
    <br>
    <button class="register" onclick="register()">‚úÖ Register</button>
    <button class="clear" onclick="clearDb()">üóëÔ∏è Clear All</button>
    <div id="result" class="info">Close eyes to mark attendance</div>


    <script>
        const STORAGE_KEY = 'FACES_DB';
        let facesDb = {};
        let lastAttendanceTime = 0;
        const COOLDOWN = 5000;
        const MODEL_URL = 'static/models';
        const MATCH_THRESHOLD = 0.5;
        let videoStream = null; // Store camera stream for release

        // Stop camera and release resources
        window.stopCamera = function () {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            const video = document.getElementById('video');
            if (video) {
                video.srcObject = null;
            }
            return 'Camera stopped';
        };

        // Send callback to C# (MAUI)
        function sendToMaui(type, data) {
            const params = new URLSearchParams(data).toString();
            window.location.href = 'callback://' + type + '?' + params;
        }

        function loadDb() {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                facesDb = data ? JSON.parse(data) : {};
                updateDbCount();
            } catch (e) { facesDb = {}; }
        }

        function saveDb() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(facesDb));
            updateDbCount();
        }

        function clearDb() {
            if (confirm('Clear all registered faces?')) {
                facesDb = {};
                localStorage.removeItem(STORAGE_KEY);
                updateDbCount();
                showResult('üóëÔ∏è All faces cleared', 'info');
                sendToMaui('cleared', { count: 0 });
            }
        }

        // function updateDbCount() {
        //     document.getElementById('dbCount').innerText = 'Registered: ' + Object.keys(facesDb).length;
        // }

        function updateDbCount() {
            const dbCountEl = document.getElementById('dbCount');
            if (dbCountEl) dbCountEl.innerText = 'Registered: ' + Object.keys(facesDb).length;
        }
        async function init() {
            loadDb();
            document.getElementById('status').innerText = 'Loading models...';

            try {
                await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
                await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);

                document.getElementById('status').innerText = 'Requesting camera...';

                const video = document.getElementById('video');
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: 420, height: 340 }
                });
                video.srcObject = videoStream;

                document.getElementById('status').innerText = '‚úÖ Ready! Close eyes to mark';
                sendToMaui('ready', { status: 'initialized' });
                video.onloadeddata = () => detectLoop();
            } catch (err) {
                document.getElementById('status').innerText = '‚ùå ' + err.message;
                sendToMaui('error', { message: err.message });
                console.error(err);
            }
        }

        async function detectLoop() {
            const video = document.getElementById('video');

            try {
                const detection = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions())
                    .withFaceLandmarks()
                    .withFaceDescriptor();

                if (detection) {
                    const now = Date.now();
                    const closed = detectEyesClosed(detection.landmarks);

                    if (closed) {
                        document.getElementById('blinkCount').innerText = 'üòë Eyes Closed!';
                        if ((now - lastAttendanceTime) > COOLDOWN) {
                            lastAttendanceTime = now;
                            markAttendance(Array.from(detection.descriptor));
                        }
                    } else {
                        document.getElementById('blinkCount').innerText = 'üëÄ Eyes Open';
                    }
                } else {
                    document.getElementById('blinkCount').innerText = '‚ùì No face';
                }
            } catch (e) { }

            requestAnimationFrame(detectLoop);
        }

        function detectEyesClosed(landmarks) {
            const leftEye = landmarks.getLeftEye();
            const rightEye = landmarks.getRightEye();
            const leftDist = Math.abs(leftEye[1].y - leftEye[5].y);
            const rightDist = Math.abs(rightEye[1].y - rightEye[5].y);
            return (leftDist < 5 && rightDist < 5);
        }

        // Store last captured image for C# to retrieve
        let lastMatchImage = null;

        function captureFrame() {
            const video = document.getElementById('video');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth || 320;
            canvas.height = video.videoHeight || 240;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            return canvas.toDataURL('image/jpeg', 0.8); // Return base64 JPEG
        }

        function markAttendance(descriptor) {
            // Block matching until reference is registered
            if (Object.keys(facesDb).length === 0) {
                showResult('‚è≥ Wait for reference to load...', 'info');
                return;
            }
            const match = findMatch(descriptor);
            if (match.name) {
                const confidence = ((1 - match.distance) * 100).toFixed(0);
                showResult('‚úÖ ' + match.name + ' (' + confidence + '%)', 'success');

                // Capture the current frame
                lastMatchImage = captureFrame();

                // Send match result to C# (image retrieved separately via getLastMatchImage)
                sendToMaui('match', {
                    name: match.name,
                    confidence: confidence,
                    isMatch: 'true',
                    hasImage: 'true'
                });
            } else {
                showResult('‚ùå Not recognized', 'error');
                lastMatchImage = null;
                sendToMaui('match', {
                    name: '',
                    confidence: '0',
                    isMatch: 'false',
                    hasImage: 'false'
                });
            }
        }

        // Expose function for C# to retrieve the captured image
        window.getLastMatchImage = function () {
            return lastMatchImage || '';
        };

        function euclideanDistance(a, b) {
            return Math.sqrt(a.reduce((sum, v, i) => sum + Math.pow(v - b[i], 2), 0));
        }

        function findMatch(descriptor, threshold = MATCH_THRESHOLD) {
            let best = { name: null, distance: Infinity };
            for (const [name, stored] of Object.entries(facesDb)) {
                const dist = euclideanDistance(descriptor, stored);
                if (dist < best.distance) best = { name, distance: dist };
            }
            return best.distance < threshold ? best : { name: null, distance: best.distance };
        }

        async function register() {
            const name = document.getElementById('name').value.trim();
            if (!name) { showResult('‚ùå Enter name', 'error'); return; }

            const video = document.getElementById('video');
            const det = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions())
                .withFaceLandmarks().withFaceDescriptor();

            if (!det) {
                showResult('‚ùå No face detected', 'error');
                sendToMaui('register', { success: 'false', name: name, error: 'No face detected' });
                return;
            }

            const descriptor = Array.from(det.descriptor);
            const match = findMatch(descriptor, 0.4);
            if (match.name) {
                showResult('‚ùå Similar to: ' + match.name, 'error');
                sendToMaui('register', { success: 'false', name: name, error: 'Similar to ' + match.name });
                return;
            }

            facesDb[name] = descriptor;
            saveDb();
            document.getElementById('name').value = '';
            showResult('‚úÖ Registered: ' + name, 'success');
            sendToMaui('register', { success: 'true', name: name, total: Object.keys(facesDb).length });
        }

        function showResult(msg, type) {
            const el = document.getElementById('result');
            el.innerText = msg;
            el.className = type || 'info';
        }

        // Expose functions to C# via EvaluateJavaScriptAsync
        window.setThreshold = function (value) {
            window.MATCH_THRESHOLD = value;
            return 'Threshold set to ' + value;
        };

        window.getRegisteredCount = function () {
            return Object.keys(facesDb).length;
        };

        window.getRegisteredNames = function () {
            return JSON.stringify(Object.keys(facesDb));
        };

        // NEW: Register from external base64 string (C#)
        window.registerExternalImage = async function (base64Data, name) {
            try {
                document.getElementById('status').innerText = '‚è≥ Processing reference...';

                const img = new Image();
                // Ensure prefix
                if (!base64Data.startsWith('data:image')) {
                    base64Data = 'data:image/jpeg;base64,' + base64Data;
                }
                img.src = base64Data;

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                });

                const det = await faceapi.detectSingleFace(img, new faceapi.TinyFaceDetectorOptions())
                    .withFaceLandmarks().withFaceDescriptor();

                if (!det) {
                    showResult('‚ùå Reference rejected: No face found', 'error');
                    sendToMaui('error', { message: 'Reference image has no face' });
                    return 'No face found';
                }

                // Clear DB for 1:1 match mode
                facesDb = {};
                facesDb[name] = Array.from(det.descriptor);
                // saveDb(); // Optional: don't save if only for this session
                updateDbCount();

                showResult('‚úÖ Reference Loaded: ' + name, 'success');
                document.getElementById('status').innerText = '‚úÖ Ready! Match against: ' + name;
                return 'Registered ' + name;
            } catch (e) {
                showResult('‚ùå Error loading reference', 'error');
                console.error(e);
                sendToMaui('error', { message: e.message });
                return e.message;
            }
        };

        init();
    </script>
</body>

</html>